import * as XLSX from 'xlsx'
import { saveAs } from 'file-saver'
import { Client, ClientTransaction, ClientSummary, ExportOptions, CompanyInfo } from '../types/client'

interface ReportData {
  client: Client
  transactions: ClientTransaction[]
  summary: ClientSummary
  reportNumber: string
  generatedBy: string
  companyInfo: CompanyInfo
}

export class ExcelReportGenerator {
  private getTranslations(language: 'EN' | 'AR') {
    return {
      EN: {
        clientReport: 'Client Financial Report',
        invoice: 'Invoice',
        statement: 'Financial Statement',
        reportNumber: 'Report Number',
        generatedOn: 'Generated On',
        generatedBy: 'Generated By',
        clientDetails: 'Client Details',
        clientName: 'Client Name',
        companyName: 'Company Name',
        email: 'Email',
        phone: 'Phone',
        address: 'Address',
        transactionHistory: 'Transaction History',
        orderNumber: 'Order Number',
        date: 'Date',
        description: 'Description',
        site: 'Project Site',
        totalAmount: 'Total Amount',
        paidAmount: 'Paid Amount',
        remaining: 'Remaining Balance',
        status: 'Payment Status',
        dueDate: 'Due Date',
        summary: 'Financial Summary',
        totalOrders: 'Total Orders',
        totalRevenue: 'Total Revenue',
        totalPaid: 'Total Paid',
        totalRemaining: 'Total Remaining',
        overdueAmount: 'Overdue Amount',
        lastTransaction: 'Last Transaction Date',
        averageOrder: 'Average Order Value',
        paid: 'Paid',
        partial: 'Partial Payment',
        pending: 'Pending',
        overdue: 'Overdue',
        authorizedBy: 'Authorized by Finance Department',
        notes: 'Notes'
      },
      AR: {
        clientReport: 'تقرير مالي للعميل',
        invoice: 'فاتورة',
        statement: 'كشف مالي',
        reportNumber: 'رقم التقرير',
        generatedOn: 'تاريخ الإنشاء',
        generatedBy: 'أنشأ بواسطة',
        clientDetails: 'تفاصيل العميل',
        clientName: 'اسم العميل',
        companyName: 'اسم الشركة',
        email: 'البريد الإلكتروني',
        phone: 'الهاتف',
        address: 'العنوان',
        transactionHistory: 'سجل المعاملات',
        orderNumber: 'رقم الطلب',
        date: 'التاريخ',
        description: 'الوصف',
        site: 'موقع المشروع',
        totalAmount: 'المبلغ الإجمالي',
        paidAmount: 'المبلغ المدفوع',
        remaining: 'الرصيد المتبقي',
        status: 'حالة الدفع',
        dueDate: 'تاريخ الاستحقاق',
        summary: 'الملخص المالي',
        totalOrders: 'إجمالي الطلبات',
        totalRevenue: 'إجمالي الإيرادات',
        totalPaid: 'إجمالي المدفوع',
        totalRemaining: 'إجمالي المتبقي',
        overdueAmount: 'المبلغ المتأخر',
        lastTransaction: 'تاريخ آخر معاملة',
        averageOrder: 'متوسط قيمة الطلب',
        paid: 'مدفوع',
        partial: 'دفع جزئي',
        pending: 'معلق',
        overdue: 'متأخر',
        authorizedBy: 'مصرح من قسم المالية',
        notes: 'ملاحظات'
      }
    }[language]
  }

  private formatCurrency(amount: number, language: 'EN' | 'AR'): string {
    const formatted = new Intl.NumberFormat('en-US').format(amount)
    return language === 'AR' ? `${formatted} د.إ` : `$${formatted}`
  }

  private getStatusText(status: ClientTransaction['status'], language: 'EN' | 'AR'): string {
    const t = this.getTranslations(language)
    return t[status] || status
  }

  async generateClientReport(
    reportData: ReportData,
    options: ExportOptions,
    reportType: 'invoice' | 'statement' | 'summary' = 'statement'
  ): Promise<Blob> {
    const t = this.getTranslations(options.language)
    const workbook = XLSX.utils.book_new()

    // Create main report worksheet
    const reportSheet = this.createReportSheet(reportData, options, reportType)
    XLSX.utils.book_append_sheet(workbook, reportSheet, t.clientReport)

    // Create summary sheet
    const summarySheet = this.createSummarySheet(reportData, options)
    XLSX.utils.book_append_sheet(workbook, summarySheet, t.summary)

    // Create transactions sheet
    const transactionsSheet = this.createTransactionsSheet(reportData, options)
    XLSX.utils.book_append_sheet(workbook, transactionsSheet, t.transactionHistory)

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })
    return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })
  }

  private createReportSheet(reportData: ReportData, options: ExportOptions, reportType: string): XLSX.WorkSheet {
    const t = this.getTranslations(options.language)
    const { client, companyInfo, summary } = reportData

    const data: any[][] = []

    // Header section
    data.push([t.clientReport])
    data.push([])
    data.push([companyInfo.name])
    data.push([`${companyInfo.address.street}, ${companyInfo.address.city}`])
    data.push([`${companyInfo.contact.phone} | ${companyInfo.contact.email}`])
    data.push([])
    
    // Report info
    data.push([t.reportNumber, reportData.reportNumber])
    data.push([t.generatedOn, new Date().toLocaleDateString(options.language === 'AR' ? 'ar-AE' : 'en-US')])
    data.push([t.generatedBy, reportData.generatedBy])
    data.push([])

    // Client details
    data.push([t.clientDetails])
    data.push([t.clientName, client.name])
    if (client.companyName) {
      data.push([t.companyName, client.companyName])
    }
    data.push([t.email, client.email])
    data.push([t.phone, client.phone])
    if (client.address) {
      data.push([t.address, client.address])
    }
    data.push([])

    // Summary section
    data.push([t.summary])
    data.push([t.totalOrders, summary.totalOrders])
    data.push([t.totalRevenue, summary.totalAmount])
    data.push([t.totalPaid, summary.totalPaid])
    data.push([t.totalRemaining, summary.totalRemaining])
    if (summary.overdueAmount > 0) {
      data.push([t.overdueAmount, summary.overdueAmount])
    }
    data.push([t.averageOrder, summary.averageOrderValue])

    const worksheet = XLSX.utils.aoa_to_sheet(data)

    // Apply formatting
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1')
    
    // Style header
    if (worksheet['A1']) {
      worksheet['A1'].s = {
        font: { bold: true, sz: 16 },
        alignment: { horizontal: options.language === 'AR' ? 'right' : 'left' }
      }
    }

    // Style section headers
    const sectionHeaders = [t.clientDetails, t.summary]
    for (let row = 0; row <= range.e.r; row++) {
      const cellRef = XLSX.utils.encode_cell({ r: row, c: 0 })
      const cell = worksheet[cellRef]
      if (cell && sectionHeaders.includes(cell.v)) {
        cell.s = {
          font: { bold: true, sz: 12 },
          fill: { fgColor: { rgb: options.theme === 'dark' ? '404040' : 'E6E6E6' } }
        }
      }
    }

    // Set column widths
    worksheet['!cols'] = [
      { wch: 25 }, // Column A
      { wch: 30 }  // Column B
    ]

    return worksheet
  }

  private createSummarySheet(reportData: ReportData, options: ExportOptions): XLSX.WorkSheet {
    const t = this.getTranslations(options.language)
    const { client, summary, companyInfo } = reportData

    const data: any[][] = []

    // Company header
    data.push([companyInfo.name])
    data.push([t.clientReport])
    data.push([])

    // Report info
    data.push([t.reportNumber, reportData.reportNumber])
    data.push([t.generatedOn, new Date().toLocaleDateString(options.language === 'AR' ? 'ar-AE' : 'en-US')])
    data.push([t.generatedBy, reportData.generatedBy])
    data.push([])

    // Client info
    data.push([t.clientDetails])
    data.push([t.clientName, client.name])
    if (client.companyName) {
      data.push([t.companyName, client.companyName])
    }
    data.push([t.email, client.email])
    data.push([t.phone, client.phone])
    data.push([])

    // Financial summary
    data.push([t.summary])
    data.push([t.totalOrders, summary.totalOrders])
    data.push([t.totalRevenue, summary.totalAmount])
    data.push([t.totalPaid, summary.totalPaid])
    data.push([t.totalRemaining, summary.totalRemaining])
    if (summary.overdueAmount > 0) {
      data.push([t.overdueAmount, summary.overdueAmount])
    }
    data.push([t.averageOrder, summary.averageOrderValue])
    if (summary.lastTransactionDate) {
      data.push([t.lastTransaction, summary.lastTransactionDate.toLocaleDateString(options.language === 'AR' ? 'ar-AE' : 'en-US')])
    }

    const worksheet = XLSX.utils.aoa_to_sheet(data)

    // Apply formatting
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1')

    // Style company name
    if (worksheet['A1']) {
      worksheet['A1'].s = {
        font: { bold: true, sz: 16 },
        alignment: { horizontal: options.language === 'AR' ? 'right' : 'left' }
      }
    }

    // Style report title
    if (worksheet['A2']) {
      worksheet['A2'].s = {
        font: { bold: true, sz: 14 },
        alignment: { horizontal: options.language === 'AR' ? 'right' : 'left' }
      }
    }

    // Style section headers
    const sectionHeaders = [t.clientDetails, t.summary]
    for (let row = 0; row <= range.e.r; row++) {
      const cellRef = XLSX.utils.encode_cell({ r: row, c: 0 })
      const cell = worksheet[cellRef]
      if (cell && sectionHeaders.includes(cell.v)) {
        cell.s = {
          font: { bold: true, sz: 12 },
          fill: { fgColor: { rgb: options.theme === 'dark' ? '404040' : 'E6E6E6' } }
        }
      }
    }

    // Format currency values
    const currencyFormat = options.language === 'AR' ? '#,##0 "د.إ"' : '"$"#,##0'
    const currencyFields = [t.totalRevenue, t.totalPaid, t.totalRemaining, t.overdueAmount, t.averageOrder]
    
    for (let row = 0; row <= range.e.r; row++) {
      const labelCell = worksheet[XLSX.utils.encode_cell({ r: row, c: 0 })]
      if (labelCell && currencyFields.includes(labelCell.v)) {
        const valueCell = worksheet[XLSX.utils.encode_cell({ r: row, c: 1 })]
        if (valueCell) {
          valueCell.s = { numFmt: currencyFormat }
        }
      }
    }

    // Set column widths
    worksheet['!cols'] = [
      { wch: 25 }, // Labels
      { wch: 20 }  // Values
    ]

    return worksheet
  }

  private createTransactionsSheet(reportData: ReportData, options: ExportOptions): XLSX.WorkSheet {
    const t = this.getTranslations(options.language)
    const { transactions } = reportData

    const headers = [
      t.orderNumber,
      t.date,
      t.description,
      t.site,
      t.totalAmount,
      t.paidAmount,
      t.remaining,
      t.status,
      t.dueDate,
      t.notes
    ]

    const data = [headers]

    transactions.forEach(transaction => {
      data.push([
        transaction.orderNumber,
        transaction.date.toLocaleDateString(options.language === 'AR' ? 'ar-AE' : 'en-US'),
        transaction.description,
        transaction.site || '-',
        transaction.totalAmount.toString(),
        transaction.paidAmount.toString(),
        transaction.remainingBalance.toString(),
        this.getStatusText(transaction.status, options.language),
        transaction.dueDate?.toLocaleDateString(options.language === 'AR' ? 'ar-AE' : 'en-US') || '-',
        transaction.notes || ''
      ])
    })

    // Add totals row
    data.push([])
    data.push([
      '', '', '', t.summary,
      `=SUM(E2:E${transactions.length + 1})`, // Total amount formula
      `=SUM(F2:F${transactions.length + 1})`, // Total paid formula
      `=SUM(G2:G${transactions.length + 1})`, // Total remaining formula
      '', '', ''
    ])

    const worksheet = XLSX.utils.aoa_to_sheet(data)

    // Apply formatting
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1')
    
    // Style header row
    for (let col = 0; col <= range.e.c; col++) {
      const cellRef = XLSX.utils.encode_cell({ r: 0, c: col })
      if (worksheet[cellRef]) {
        worksheet[cellRef].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: options.theme === 'dark' ? '404040' : 'E6E6E6' } },
          alignment: { horizontal: 'center' }
        }
      }
    }

    // Style totals row
    const totalsRow = transactions.length + 2
    for (let col = 0; col <= range.e.c; col++) {
      const cellRef = XLSX.utils.encode_cell({ r: totalsRow, c: col })
      if (worksheet[cellRef]) {
        worksheet[cellRef].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: options.theme === 'dark' ? '505050' : 'D6D6D6' } }
        }
      }
    }

    // Format currency columns
    const currencyFormat = options.language === 'AR' ? '#,##0 "د.إ"' : '"$"#,##0'
    for (let row = 1; row <= transactions.length; row++) {
      // Total Amount (column E)
      const totalCell = XLSX.utils.encode_cell({ r: row, c: 4 })
      if (worksheet[totalCell]) {
        worksheet[totalCell].s = { numFmt: currencyFormat }
      }
      
      // Paid Amount (column F)
      const paidCell = XLSX.utils.encode_cell({ r: row, c: 5 })
      if (worksheet[paidCell]) {
        worksheet[paidCell].s = { numFmt: currencyFormat }
      }
      
      // Remaining (column G)
      const remainingCell = XLSX.utils.encode_cell({ r: row, c: 6 })
      if (worksheet[remainingCell]) {
        worksheet[remainingCell].s = { numFmt: currencyFormat }
      }
    }

    // Set column widths
    worksheet['!cols'] = [
      { wch: 15 }, // Order Number
      { wch: 12 }, // Date
      { wch: 30 }, // Description
      { wch: 15 }, // Site
      { wch: 15 }, // Total Amount
      { wch: 15 }, // Paid Amount
      { wch: 15 }, // Remaining
      { wch: 12 }, // Status
      { wch: 12 }, // Due Date
      { wch: 20 }  // Notes
    ]

    return worksheet
  }

  async downloadReport(
    reportData: ReportData,
    options: ExportOptions,
    reportType: 'invoice' | 'statement' | 'summary' = 'statement'
  ): Promise<void> {
    const blob = await this.generateClientReport(reportData, options, reportType)
    const filename = `${reportType}_${reportData.client.name.replace(/\s+/g, '_')}_${reportData.reportNumber}.xlsx`
    
    saveAs(blob, filename)
  }

  async generateQuickSummaryExcel(clients: Client[], allTransactions: ClientTransaction[], options: ExportOptions): Promise<void> {
    const t = this.getTranslations(options.language)
    const workbook = XLSX.utils.book_new()

    // Create clients overview sheet
    const clientsData: any[][] = []
    clientsData.push([
      t.clientName,
      t.companyName,
      t.email,
      t.phone,
      t.totalOrders,
      t.totalRevenue,
      t.totalPaid,
      t.totalRemaining,
      t.overdueAmount
    ])

    for (const client of clients) {
      const clientTransactions = allTransactions.filter(t => t.clientId === client.id)
      const totalOrders = clientTransactions.length
      const totalAmount = clientTransactions.reduce((sum, t) => sum + t.totalAmount, 0)
      const totalPaid = clientTransactions.reduce((sum, t) => sum + t.paidAmount, 0)
      const totalRemaining = clientTransactions.reduce((sum, t) => sum + t.remainingBalance, 0)
      const overdueAmount = clientTransactions
        .filter(t => t.status === 'overdue' || (t.dueDate && new Date(t.dueDate) < new Date() && t.remainingBalance > 0))
        .reduce((sum, t) => sum + t.remainingBalance, 0)

      clientsData.push([
        client.name,
        client.companyName || '-',
        client.email,
        client.phone,
        totalOrders,
        totalAmount,
        totalPaid,
        totalRemaining,
        overdueAmount
      ])
    }

    const clientsSheet = XLSX.utils.aoa_to_sheet(clientsData)

    // Format the sheet
    const range = XLSX.utils.decode_range(clientsSheet['!ref'] || 'A1')
    
    // Style header
    for (let col = 0; col <= range.e.c; col++) {
      const cellRef = XLSX.utils.encode_cell({ r: 0, c: col })
      if (clientsSheet[cellRef]) {
        clientsSheet[cellRef].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: options.theme === 'dark' ? '404040' : 'E6E6E6' } },
          alignment: { horizontal: 'center' }
        }
      }
    }

    // Format currency columns
    const currencyFormat = options.language === 'AR' ? '#,##0 "د.إ"' : '"$"#,##0'
    const currencyColumns = [5, 6, 7, 8] // Total Revenue, Total Paid, Total Remaining, Overdue Amount

    for (let row = 1; row <= range.e.r; row++) {
      currencyColumns.forEach(col => {
        const cellRef = XLSX.utils.encode_cell({ r: row, c: col })
        if (clientsSheet[cellRef]) {
          clientsSheet[cellRef].s = { numFmt: currencyFormat }
        }
      })
    }

    // Set column widths
    clientsSheet['!cols'] = [
      { wch: 20 }, // Client Name
      { wch: 25 }, // Company Name
      { wch: 25 }, // Email
      { wch: 15 }, // Phone
      { wch: 12 }, // Total Orders
      { wch: 15 }, // Total Revenue
      { wch: 15 }, // Total Paid
      { wch: 15 }, // Total Remaining
      { wch: 15 }  // Overdue Amount
    ]

    XLSX.utils.book_append_sheet(workbook, clientsSheet, 'Clients Overview')

    // Generate and download
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' })
    
    const filename = `clients_summary_${new Date().toISOString().split('T')[0]}.xlsx`
    saveAs(blob, filename)
  }
}

export const excelReportGenerator = new ExcelReportGenerator()
export default excelReportGenerator
